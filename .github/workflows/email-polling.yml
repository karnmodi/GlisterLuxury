name: Email Auto-Reply Polling

on:
  schedule:
    # Run every minute
    - cron: '* * * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  trigger-email-polling:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Trigger Email Polling
        run: |
          # Get Vercel URL from GitHub secret or use default
          VERCEL_URL="${{ secrets.VERCEL_URL }}"
          
          # If VERCEL_URL secret is not set, use default (you should set this in GitHub secrets)
          if [ -z "$VERCEL_URL" ]; then
            echo "âš ï¸ VERCEL_URL secret not set, using default URL"
            echo "ğŸ’¡ Tip: Set VERCEL_URL secret in GitHub for better reliability"
            # Default URL - UPDATE THIS with your actual Vercel URL
            VERCEL_URL="https://glister-london-l2w3.vercel.app"
          fi
          
          # Get cron secret from GitHub secrets
          CRON_SECRET="${{ secrets.CRON_SECRET }}"
          
          if [ -z "$CRON_SECRET" ]; then
            echo "âŒ Error: CRON_SECRET is not set in GitHub secrets"
            echo "Please set CRON_SECRET in: Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          fi
          
          # Construct the endpoint URL
          ENDPOINT="${VERCEL_URL}/api/incoming-email/cron"
          
          echo "ğŸš€ Triggering email polling..."
          echo "ğŸ“ Endpoint: ${ENDPOINT}"
          echo "â° Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
          # Make the request with token as query parameter
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "${ENDPOINT}?token=${CRON_SECRET}" \
            -H "User-Agent: GitHub-Actions-Email-Polling/1.0" \
            -H "X-GitHub-Action: email-polling" \
            -H "X-GitHub-Repository: ${{ github.repository }}" \
            --max-time 300 \
            --connect-timeout 30)
          
          # Extract HTTP status code (last line)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          # Extract response body (all but last line)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo ""
          echo "ğŸ“Š Response Details:"
          echo "HTTP Status Code: ${HTTP_CODE}"
          echo "Response Body: ${BODY}"
          
          # Check if request was successful
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo ""
            echo "âœ… Email polling triggered successfully"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“§ EMAIL PROCESSING DETAILS"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Parse and display results if available
            if echo "$BODY" | grep -q "emailsProcessed"; then
              EMAILS_PROCESSED=$(echo "$BODY" | grep -o '"emailsProcessed":[0-9]*' | cut -d':' -f2 || echo "0")
              echo "ğŸ“Š Total Emails Processed: ${EMAILS_PROCESSED}"
              echo ""
            fi
            
            # Parse and display detailed email information
            # Check if details array exists in response
            if echo "$BODY" | grep -q '"details":\['; then
              echo "ğŸ“‹ Detailed Email Log:"
              echo ""
              
              # Extract details array and process each entry
              # Use Python or jq if available, otherwise use basic parsing
              if command -v python3 &> /dev/null; then
                PYTHON_SCRIPT="aW1wb3J0IGpzb24KaW1wb3J0IHN5cwoKdHJ5OgogICAgYm9keSA9IHN5cy5zdGRpbi5yZWFkKCkKICAgIGRhdGEgPSBqc29uLmxvYWRzKGJvZHkpCiAgICBkZXRhaWxzID0gZGF0YS5nZXQoJ2RldGFpbHMnLCBbXSkKICAgIAogICAgaWYgbm90IGRldGFpbHM6CiAgICAgICAgcHJpbnQoJyAgIOKEue+4jyAgTm8gZW1haWxzIHRvIHByb2Nlc3MnKQogICAgZWxzZToKICAgICAgICBmb3IgaSwgeCBpbiBlbnVtZXJhdGUoZGV0YWlscywgMSk6CiAgICAgICAgICAgIHN0YXR1cyA9IHguZ2V0KCdzdGF0dXMnLCAndW5rbm93bicpCiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHguZ2V0KCd0aW1lc3RhbXAnLCAnJykKICAgICAgICAgICAgdGltZV9zdHIgPSB0aW1lc3RhbXAuc3BsaXQoJ1QnKVsxXS5zcGxpdCgnLicpWzBdIGlmICdUJyBpbiB0aW1lc3RhbXAgZWxzZSAnJwogICAgICAgICAgICByZWNlaXZlZCA9IHguZ2V0KCdyZWNlaXZlZEZyb20nLCB7fSkKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIHN0YXR1cyA9PSAncmVjZWl2ZWQnOgogICAgICAgICAgICAgICAgcHJpbnQoZicgICDwn5OlIFt7aX1dIE5FVyBFTUFJTCBSRUNFSVZFRCcpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFRpbWU6IHt0aW1lX3N0cn0nKQogICAgICAgICAgICAgICAgbmFtZSA9IHJlY2VpdmVkLmdldCgnbmFtZScsICdVbmtub3duJykKICAgICAgICAgICAgICAgIGVtYWlsID0gcmVjZWl2ZWQuZ2V0KCdlbWFpbCcsICd1bmtub3duJykKICAgICAgICAgICAgICAgIHByaW50KGYnICAgICAgRnJvbToge25hbWV9IDx7ZW1haWx9PicpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFN1YmplY3Q6IHtyZWNlaXZlZC5nZXQoInN1YmplY3QiLCAiTm8gU3ViamVjdCIpfScpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFJlY2VpdmVkIEF0OiB7eC5nZXQoInJlY2VpdmVkQXQiLCAiIil9JykKICAgICAgICAgICAgICAgIHByaW50KCcnKQogICAgICAgICAgICBlbGlmIHN0YXR1cyA9PSAnc2VudCc6CiAgICAgICAgICAgICAgICBhdXRvX3JlcGx5ID0geC5nZXQoJ2F1dG9SZXBseVNlbnQnLCB7fSkKICAgICAgICAgICAgICAgIHByaW50KGYnICAg4pyFIFt7aX1dIEFVVE8tUkVQTFkgU0VOVCcpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFRpbWU6IHt0aW1lX3N0cn0nKQogICAgICAgICAgICAgICAgbmFtZSA9IHJlY2VpdmVkLmdldCgnbmFtZScsICdVbmtub3duJykKICAgICAgICAgICAgICAgIGVtYWlsID0gcmVjZWl2ZWQuZ2V0KCdlbWFpbCcsICd1bmtub3duJykKICAgICAgICAgICAgICAgIHByaW50KGYnICAgICAgT3JpZ2luYWwgRW1haWwgRnJvbToge25hbWV9IDx7ZW1haWx9PicpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIE9yaWdpbmFsIFN1YmplY3Q6IHtyZWNlaXZlZC5nZXQoInN1YmplY3QiLCAiTm8gU3ViamVjdCIpfScpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIEF1dG8tUmVwbHkgVG86IHthdXRvX3JlcGx5LmdldCgidG8iLCAidW5rbm93biIpfScpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIEF1dG8tUmVwbHkgRnJvbToge2F1dG9fcmVwbHkuZ2V0KCJmcm9tIiwgInVua25vd24iKX0nKQogICAgICAgICAgICAgICAgcHJpbnQoZicgICAgICBBdXRvLVJlcGx5IFN1YmplY3Q6IHthdXRvX3JlcGx5LmdldCgic3ViamVjdCIsICJObyBTdWJqZWN0Iil9JykKICAgICAgICAgICAgICAgIG1lc3NhZ2VfcHJldmlldyA9IGF1dG9fcmVwbHkuZ2V0KCdtZXNzYWdlUHJldmlldycsICcnKQogICAgICAgICAgICAgICAgaWYgbWVzc2FnZV9wcmV2aWV3OgogICAgICAgICAgICAgICAgICAgIHByaW50KGYnICAgICAgTWVzc2FnZSBQcmV2aWV3OiB7bWVzc2FnZV9wcmV2aWV3WzoxMDBdfScpCiAgICAgICAgICAgICAgICBwcmludCgnJykKICAgICAgICAgICAgZWxpZiBzdGF0dXMgPT0gJ2ZhaWxlZCc6CiAgICAgICAgICAgICAgICBmYWlsZWQgPSB4LmdldCgnYXV0b1JlcGx5RmFpbGVkJywge30pCiAgICAgICAgICAgICAgICBwcmludChmJyAgIOKdjCBbe2l9XSBBVVRPLVJFUExZIEZBSUxFRCcpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFRpbWU6IHt0aW1lX3N0cn0nKQogICAgICAgICAgICAgICAgbmFtZSA9IHJlY2VpdmVkLmdldCgnbmFtZScsICdVbmtub3duJykKICAgICAgICAgICAgICAgIGVtYWlsID0gcmVjZWl2ZWQuZ2V0KCdlbWFpbCcsICd1bmtub3duJykKICAgICAgICAgICAgICAgIHByaW50KGYnICAgICAgRnJvbToge25hbWV9IDx7ZW1haWx9PicpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFN1YmplY3Q6IHtyZWNlaXZlZC5nZXQoInN1YmplY3QiLCAiTm8gU3ViamVjdCIpfScpCiAgICAgICAgICAgICAgICBwcmludChmJyAgICAgIFJlYXNvbjoge2ZhaWxlZC5nZXQoInJlYXNvbiIsICJVbmtub3duIGVycm9yIil9JykKICAgICAgICAgICAgICAgIHByaW50KCcnKQpleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICBwcmludChmJyAgIOKaoO+4jyAgQ291bGQgbm90IHBhcnNlIGRldGFpbGVkIGluZm9ybWF0aW9uOiB7c3RyKGUpfScpCg=="
                echo "$BODY" | python3 -c "import base64, sys; exec(base64.b64decode('$PYTHON_SCRIPT').decode('utf-8'))"
              elif command -v jq &> /dev/null; then
                echo "$BODY" | jq -r '.details[]? | "   " + (if .status == "received" then "ğŸ“¥ NEW EMAIL RECEIVED" elif .status == "sent" then "âœ… AUTO-REPLY SENT" elif .status == "failed" then "âŒ AUTO-REPLY FAILED" else "â„¹ï¸ " + .status end) + "\n" + "      Time: " + (.timestamp // "unknown" | split("T")[1] | split(".")[0]) + "\n" + (if .receivedFrom then "      From: " + (.receivedFrom.name // "Unknown") + " <" + (.receivedFrom.email // "unknown") + ">\n" + "      Subject: " + (.receivedFrom.subject // "No Subject") + "\n" else "" end) + (if .autoReplySent then "      Auto-Reply To: " + (.autoReplySent.to // "unknown") + "\n" + "      Auto-Reply Subject: " + (.autoReplySent.subject // "No Subject") + "\n" else "" end) + (if .autoReplyFailed then "      Reason: " + (.autoReplyFailed.reason // "Unknown") + "\n" else "" end) + ""'
              else
                # Fallback: Basic text parsing
                echo "   â„¹ï¸  Install python3 or jq for detailed parsing"
                echo "   Raw details available in response body above"
              fi
            else
              echo "   â„¹ï¸  No detailed email information in response"
            fi
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            if echo "$BODY" | grep -q '"errors":\[.*\]' && ! echo "$BODY" | grep -q '"errors":\[\]'; then
              echo ""
              echo "âš ï¸ Some errors occurred during processing"
            fi
            
            exit 0
          else
            echo ""
            echo "âŒ Email polling failed with status code: ${HTTP_CODE}"
            echo "Response: ${BODY}"
            
            # Provide helpful error messages
            if [ "$HTTP_CODE" -eq 401 ]; then
              echo ""
              echo "ğŸ”’ Authentication failed. Please verify:"
              echo "   1. CRON_SECRET in GitHub secrets matches Vercel environment variable"
              echo "   2. Secret is set correctly (no extra spaces)"
            elif [ "$HTTP_CODE" -eq 404 ]; then
              echo ""
              echo "ğŸ” Endpoint not found. Please verify:"
              echo "   1. VERCEL_URL is correct"
              echo "   2. Endpoint path: /api/incoming-email/cron"
              echo "   3. Deployment is live on Vercel"
            elif [ "$HTTP_CODE" -eq 000 ] || [ -z "$HTTP_CODE" ]; then
              echo ""
              echo "ğŸŒ Connection failed. Please verify:"
              echo "   1. Vercel deployment is accessible"
              echo "   2. VERCEL_URL is correct"
              echo "   3. Network connectivity"
            fi
            
            # Don't fail the workflow - just log the error
            # This allows the workflow to continue running even if one execution fails
            exit 0
          fi
          
      - name: Log Execution Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ Execution Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Workflow: Email Auto-Reply Polling"
          echo "Triggered: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "Repository: ${{ github.repository }}"
          echo "Commit: ${{ github.sha }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

