name: Email Auto-Reply Polling

on:
  schedule:
    # Run every minute
    - cron: '* * * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  trigger-email-polling:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Trigger Email Polling
        run: |
          # Get Vercel URL from GitHub secret or use default
          VERCEL_URL="${{ secrets.VERCEL_URL }}"
          
          # If VERCEL_URL secret is not set, use default (you should set this in GitHub secrets)
          if [ -z "$VERCEL_URL" ]; then
            echo "âš ï¸ VERCEL_URL secret not set, using default URL"
            echo "ğŸ’¡ Tip: Set VERCEL_URL secret in GitHub for better reliability"
            # Default URL - UPDATE THIS with your actual Vercel URL
            VERCEL_URL="https://glister-london-l2w3.vercel.app"
          fi
          
          # Get cron secret from GitHub secrets
          CRON_SECRET="${{ secrets.CRON_SECRET }}"
          
          if [ -z "$CRON_SECRET" ]; then
            echo "âŒ Error: CRON_SECRET is not set in GitHub secrets"
            echo "Please set CRON_SECRET in: Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          fi
          
          # Construct the endpoint URL
          ENDPOINT="${VERCEL_URL}/api/incoming-email/cron"
          
          echo "ğŸš€ Triggering email polling..."
          echo "ğŸ“ Endpoint: ${ENDPOINT}"
          echo "â° Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
          # Make the request with token as query parameter
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "${ENDPOINT}?token=${CRON_SECRET}" \
            -H "User-Agent: GitHub-Actions-Email-Polling/1.0" \
            -H "X-GitHub-Action: email-polling" \
            -H "X-GitHub-Repository: ${{ github.repository }}" \
            --max-time 300 \
            --connect-timeout 30)
          
          # Extract HTTP status code (last line)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          # Extract response body (all but last line)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo ""
          echo "ğŸ“Š Response Details:"
          echo "HTTP Status Code: ${HTTP_CODE}"
          echo "Response Body: ${BODY}"
          
          # Check if request was successful
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo ""
            echo "âœ… Email polling triggered successfully"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“§ EMAIL PROCESSING DETAILS"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Parse and display results if available
            if echo "$BODY" | grep -q "emailsProcessed"; then
              EMAILS_PROCESSED=$(echo "$BODY" | grep -o '"emailsProcessed":[0-9]*' | cut -d':' -f2 || echo "0")
              echo "ğŸ“Š Total Emails Processed: ${EMAILS_PROCESSED}"
              echo ""
            fi
            
            # Parse and display detailed email information
            # Check if details array exists in response
            if echo "$BODY" | grep -q '"details":\['; then
              echo "ğŸ“‹ Detailed Email Log:"
              echo ""
              
              # Extract details array and process each entry
              # Use Python or jq if available, otherwise use basic parsing
              if command -v python3 &> /dev/null; then
                printf '%s\n' 'import json,sys' 'try:' '  d=json.load(sys.stdin)' '  details=d.get("details",[])' '  if not details:' '    print("   â„¹ï¸  No emails to process")' '  else:' '    for i,x in enumerate(details,1):' '      s=x.get("status","unknown")' '      t=x.get("timestamp","")' '      ts=t.split("T")[1].split(".")[0] if "T" in t else ""' '      rf=x.get("receivedFrom",{})' '      if s=="received":' '        print(f"   ğŸ“¥ [{i}] NEW EMAIL RECEIVED")' '        print(f"      Time: {ts}")' '        print(f"      From: {rf.get(\"name\",\"Unknown\")} <{rf.get(\"email\",\"unknown\")}>")' '        print(f"      Subject: {rf.get(\"subject\",\"No Subject\")}")' '        print(f"      Received At: {x.get(\"receivedAt\",\"\")}")' '        print("")' '      elif s=="sent":' '        ar=x.get("autoReplySent",{})' '        print(f"   âœ… [{i}] AUTO-REPLY SENT")' '        print(f"      Time: {ts}")' '        print(f"      Original Email From: {rf.get(\"name\",\"Unknown\")} <{rf.get(\"email\",\"unknown\")}>")' '        print(f"      Original Subject: {rf.get(\"subject\",\"No Subject\")}")' '        print(f"      Auto-Reply To: {ar.get(\"to\",\"unknown\")}")' '        print(f"      Auto-Reply From: {ar.get(\"from\",\"unknown\")}")' '        print(f"      Auto-Reply Subject: {ar.get(\"subject\",\"No Subject\")}")' '        mp=ar.get("messagePreview","")' '        if mp: print(f"      Message Preview: {mp[:100]}")' '        print("")' '      elif s=="failed":' '        af=x.get("autoReplyFailed",{})' '        print(f"   âŒ [{i}] AUTO-REPLY FAILED")' '        print(f"      Time: {ts}")' '        print(f"      From: {rf.get(\"name\",\"Unknown\")} <{rf.get(\"email\",\"unknown\")}>")' '        print(f"      Subject: {rf.get(\"subject\",\"No Subject\")}")' '        print(f"      Reason: {af.get(\"reason\",\"Unknown error\")}")' '        print("")' 'except Exception as e:' '  print(f"   âš ï¸  Could not parse: {str(e)}")' > /tmp/parse.py
                echo "$BODY" | python3 /tmp/parse.py
                rm -f /tmp/parse.py
              elif command -v jq &> /dev/null; then
                echo "$BODY" | jq -r '.details[]? | "   " + (if .status == "received" then "ğŸ“¥ NEW EMAIL RECEIVED" elif .status == "sent" then "âœ… AUTO-REPLY SENT" elif .status == "failed" then "âŒ AUTO-REPLY FAILED" else "â„¹ï¸ " + .status end) + "\n" + "      Time: " + (.timestamp // "unknown" | split("T")[1] | split(".")[0]) + "\n" + (if .receivedFrom then "      From: " + (.receivedFrom.name // "Unknown") + " <" + (.receivedFrom.email // "unknown") + ">\n" + "      Subject: " + (.receivedFrom.subject // "No Subject") + "\n" else "" end) + (if .autoReplySent then "      Auto-Reply To: " + (.autoReplySent.to // "unknown") + "\n" + "      Auto-Reply Subject: " + (.autoReplySent.subject // "No Subject") + "\n" else "" end) + (if .autoReplyFailed then "      Reason: " + (.autoReplyFailed.reason // "Unknown") + "\n" else "" end) + ""'
              else
                # Fallback: Basic text parsing
                echo "   â„¹ï¸  Install python3 or jq for detailed parsing"
                echo "   Raw details available in response body above"
              fi
            else
              echo "   â„¹ï¸  No detailed email information in response"
            fi
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            if echo "$BODY" | grep -q '"errors":\[.*\]' && ! echo "$BODY" | grep -q '"errors":\[\]'; then
              echo ""
              echo "âš ï¸ Some errors occurred during processing"
            fi
            
            exit 0
          else
            echo ""
            echo "âŒ Email polling failed with status code: ${HTTP_CODE}"
            echo "Response: ${BODY}"
            
            # Provide helpful error messages
            if [ "$HTTP_CODE" -eq 401 ]; then
              echo ""
              echo "ğŸ”’ Authentication failed. Please verify:"
              echo "   1. CRON_SECRET in GitHub secrets matches Vercel environment variable"
              echo "   2. Secret is set correctly (no extra spaces)"
            elif [ "$HTTP_CODE" -eq 404 ]; then
              echo ""
              echo "ğŸ” Endpoint not found. Please verify:"
              echo "   1. VERCEL_URL is correct"
              echo "   2. Endpoint path: /api/incoming-email/cron"
              echo "   3. Deployment is live on Vercel"
            elif [ "$HTTP_CODE" -eq 000 ] || [ -z "$HTTP_CODE" ]; then
              echo ""
              echo "ğŸŒ Connection failed. Please verify:"
              echo "   1. Vercel deployment is accessible"
              echo "   2. VERCEL_URL is correct"
              echo "   3. Network connectivity"
            fi
            
            # Don't fail the workflow - just log the error
            # This allows the workflow to continue running even if one execution fails
            exit 0
          fi
          
      - name: Log Execution Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ Execution Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Workflow: Email Auto-Reply Polling"
          echo "Triggered: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "Repository: ${{ github.repository }}"
          echo "Commit: ${{ github.sha }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

