name: Email Auto-Reply Polling

on:
  schedule:
    # Run every minute
    - cron: '* * * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  trigger-email-polling:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Trigger Email Polling
        run: |
          # Get Vercel URL from GitHub secret or use default
          VERCEL_URL="${{ secrets.VERCEL_URL }}"
          
          # If VERCEL_URL secret is not set, use default (you should set this in GitHub secrets)
          if [ -z "$VERCEL_URL" ]; then
            echo "âš ï¸ VERCEL_URL secret not set, using default URL"
            echo "ğŸ’¡ Tip: Set VERCEL_URL secret in GitHub for better reliability"
            # Default URL - UPDATE THIS with your actual Vercel URL
            VERCEL_URL="https://glister-london-l2w3.vercel.app"
          fi
          
          # Get cron secret from GitHub secrets
          CRON_SECRET="${{ secrets.CRON_SECRET }}"
          
          if [ -z "$CRON_SECRET" ]; then
            echo "âŒ Error: CRON_SECRET is not set in GitHub secrets"
            echo "Please set CRON_SECRET in: Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          fi
          
          # Construct the endpoint URL
          ENDPOINT="${VERCEL_URL}/api/incoming-email/cron"
          
          echo "ğŸš€ Triggering email polling..."
          echo "ğŸ“ Endpoint: ${ENDPOINT}"
          echo "â° Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
          # Make the request with token as query parameter
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "${ENDPOINT}?token=${CRON_SECRET}" \
            -H "User-Agent: GitHub-Actions-Email-Polling/1.0" \
            -H "X-GitHub-Action: email-polling" \
            -H "X-GitHub-Repository: ${{ github.repository }}" \
            --max-time 300 \
            --connect-timeout 30)
          
          # Extract HTTP status code (last line)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          # Extract response body (all but last line)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo ""
          echo "ğŸ“Š Response Details:"
          echo "HTTP Status Code: ${HTTP_CODE}"
          echo "Response Body: ${BODY}"
          
          # Check if request was successful
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo ""
            echo "âœ… Email polling triggered successfully"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“§ EMAIL PROCESSING DETAILS"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Parse and display results if available
            if echo "$BODY" | grep -q "emailsProcessed"; then
              EMAILS_PROCESSED=$(echo "$BODY" | grep -o '"emailsProcessed":[0-9]*' | cut -d':' -f2 || echo "0")
              echo "ğŸ“Š Total Emails Processed: ${EMAILS_PROCESSED}"
              echo ""
            fi
            
            # Parse and display detailed email information
            # Check if details array exists in response
            if echo "$BODY" | grep -q '"details":\['; then
              echo "ğŸ“‹ Detailed Email Log:"
              echo ""
              
              # Extract details array and process each entry
              # Use Python or jq if available, otherwise use basic parsing
              if command -v python3 &> /dev/null; then
                cat > /tmp/parse_emails.py << 'ENDOFPYTHON'
import json
import sys

try:
    body = sys.stdin.read()
    data = json.loads(body)
    
    if 'details' in data and isinstance(data['details'], list):
        details = data['details']
        
        if len(details) == 0:
            print('   â„¹ï¸  No emails to process')
        else:
            for i, detail in enumerate(details, 1):
                status = detail.get('status', 'unknown')
                timestamp = detail.get('timestamp', '')
                time_str = timestamp.split('T')[1].split('.')[0] if 'T' in timestamp else timestamp
                
                if status == 'received':
                    received = detail.get('receivedFrom', {})
                    received_at = detail.get('receivedAt', '')
                    print(f'   ğŸ“¥ [{i}] NEW EMAIL RECEIVED')
                    print(f'      Time: {time_str}')
                    print(f'      From: {received.get("name", "Unknown")} <{received.get("email", "unknown")}>')
                    print(f'      Subject: {received.get("subject", "No Subject")}')
                    print(f'      Received At: {received_at}')
                    print('')
                
                elif status == 'sent':
                    received = detail.get('receivedFrom', {})
                    auto_reply = detail.get('autoReplySent', {})
                    print(f'   âœ… [{i}] AUTO-REPLY SENT')
                    print(f'      Time: {time_str}')
                    print(f'      Original Email From: {received.get("name", "Unknown")} <{received.get("email", "unknown")}>')
                    print(f'      Original Subject: {received.get("subject", "No Subject")}')
                    print(f'      Auto-Reply To: {auto_reply.get("to", "unknown")}')
                    print(f'      Auto-Reply From: {auto_reply.get("from", "unknown")}')
                    print(f'      Auto-Reply Subject: {auto_reply.get("subject", "No Subject")}')
                    message_preview = auto_reply.get('messagePreview', '')
                    if message_preview:
                        print(f'      Message Preview: {message_preview}')
                    print('')
                
                elif status == 'failed':
                    received = detail.get('receivedFrom', {})
                    failed = detail.get('autoReplyFailed', {})
                    print(f'   âŒ [{i}] AUTO-REPLY FAILED')
                    print(f'      Time: {time_str}')
                    print(f'      From: {received.get("name", "Unknown")} <{received.get("email", "unknown")}>')
                    print(f'      Subject: {received.get("subject", "No Subject")}')
                    print(f'      Reason: {failed.get("reason", "Unknown error")}')
                    print('')
    else:
        print('   â„¹ï¸  No detailed information available')
except Exception as e:
    print(f'   âš ï¸  Could not parse detailed information: {str(e)}')
ENDOFPYTHON
                echo "$BODY" | python3 /tmp/parse_emails.py
                rm -f /tmp/parse_emails.py
              elif command -v jq &> /dev/null; then
                echo "$BODY" | jq -r '.details[]? | "   " + (if .status == "received" then "ğŸ“¥ NEW EMAIL RECEIVED" elif .status == "sent" then "âœ… AUTO-REPLY SENT" elif .status == "failed" then "âŒ AUTO-REPLY FAILED" else "â„¹ï¸ " + .status end) + "\n" + "      Time: " + (.timestamp // "unknown" | split("T")[1] | split(".")[0]) + "\n" + (if .receivedFrom then "      From: " + (.receivedFrom.name // "Unknown") + " <" + (.receivedFrom.email // "unknown") + ">\n" + "      Subject: " + (.receivedFrom.subject // "No Subject") + "\n" else "" end) + (if .autoReplySent then "      Auto-Reply To: " + (.autoReplySent.to // "unknown") + "\n" + "      Auto-Reply Subject: " + (.autoReplySent.subject // "No Subject") + "\n" else "" end) + (if .autoReplyFailed then "      Reason: " + (.autoReplyFailed.reason // "Unknown") + "\n" else "" end) + ""'
              else
                # Fallback: Basic text parsing
                echo "   â„¹ï¸  Install python3 or jq for detailed parsing"
                echo "   Raw details available in response body above"
              fi
            else
              echo "   â„¹ï¸  No detailed email information in response"
            fi
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            if echo "$BODY" | grep -q '"errors":\[.*\]' && ! echo "$BODY" | grep -q '"errors":\[\]'; then
              echo ""
              echo "âš ï¸ Some errors occurred during processing"
            fi
            
            exit 0
          else
            echo ""
            echo "âŒ Email polling failed with status code: ${HTTP_CODE}"
            echo "Response: ${BODY}"
            
            # Provide helpful error messages
            if [ "$HTTP_CODE" -eq 401 ]; then
              echo ""
              echo "ğŸ”’ Authentication failed. Please verify:"
              echo "   1. CRON_SECRET in GitHub secrets matches Vercel environment variable"
              echo "   2. Secret is set correctly (no extra spaces)"
            elif [ "$HTTP_CODE" -eq 404 ]; then
              echo ""
              echo "ğŸ” Endpoint not found. Please verify:"
              echo "   1. VERCEL_URL is correct"
              echo "   2. Endpoint path: /api/incoming-email/cron"
              echo "   3. Deployment is live on Vercel"
            elif [ "$HTTP_CODE" -eq 000 ] || [ -z "$HTTP_CODE" ]; then
              echo ""
              echo "ğŸŒ Connection failed. Please verify:"
              echo "   1. Vercel deployment is accessible"
              echo "   2. VERCEL_URL is correct"
              echo "   3. Network connectivity"
            fi
            
            # Don't fail the workflow - just log the error
            # This allows the workflow to continue running even if one execution fails
            exit 0
          fi
          
      - name: Log Execution Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ Execution Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Workflow: Email Auto-Reply Polling"
          echo "Triggered: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "Repository: ${{ github.repository }}"
          echo "Commit: ${{ github.sha }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

